# -*- coding: utf-8 -*-

# GIL 全局解释器锁  Cpython解释器特性（解释性语言弊端）
# ----> 同一时刻只能有一个线程访问CPU
# 锁住的是线程
# ----> 高CPU：计算类 使用多进程效率高
# ----> 高IO：使用多线程效率高

# Python代码的执行由Python虚拟机(也叫解释器主循环)来控制。
# Python在设计之初就考虑到要在主循环中，
# 同时只有一个线程在执行。虽然 Python 解释器中可以“运行”多个线程，但在任意时刻只有一个线程在解释器中运行。
# 　　对Python虚拟机的访问由全局解释器锁(GIL)来控制，正是这个锁能保证同一时刻只有一个线程在运行。
#
# 　　在多线程环境中，Python 虚拟机按以下方式执行：
#
# 　　a、设置 GIL；
#
# 　　b、切换到一个线程去运行；
#
# 　　c、运行指定数量的字节码指令或者线程主动让出控制(可以调用 time.sleep(0))；
#
# 　　d、把线程设置为睡眠状态；
#
# 　　e、解锁 GIL；
#
# 　　d、再次重复以上所有步骤。
# 　　在调用外部代码(如 C/C++扩展函数)的时候，GIL将会被锁定，
# 直到这个函数结束为止(由于在这期间没有Python的字节码被运行，
# 所以不会做线程切换)编写扩展的程序员可以主动解锁GIL。

# ----> 守护进程 守护进程在主进程代码执行完毕后结束，回收守护进程的资源
# ----> 守护线程 守护线程在主线程代码执行完毕后要等待其他非守护线程结束之后才结束。
# 因为线程之间是共享资源的，必须保证非守护线程执行完完毕之后，才能回收资源
